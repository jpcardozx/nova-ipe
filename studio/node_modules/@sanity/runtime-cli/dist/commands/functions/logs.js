import { Args, Command, Flags } from '@oclif/core';
import Spinner from 'yocto-spinner';
import { readBlueprintOnDisk } from '../../actions/blueprints/blueprint.js';
import { logs as logsAction } from '../../actions/functions/logs.js';
import config from '../../config.js';
import { formatTitle } from '../../utils/display/blueprints-formatting.js';
import { blue, bold, green, red, yellow } from '../../utils/display/colors.js';
import { findFunctionByName } from '../../utils/find-function.js';
function logLevel(level) {
    if (level === 'ERROR') {
        return red(level);
    }
    if (level === 'WARN') {
        return yellow(level);
    }
    return green(level);
}
export default class Logs extends Command {
    static args = {
        name: Args.string({ description: 'The name of the Sanity Function', required: true }),
    };
    static description = 'Retrieve logs for a Sanity Function';
    static examples = [
        '<%= config.bin %> <%= command.id %> <name>',
        '<%= config.bin %> <%= command.id %> <name> --json',
        '<%= config.bin %> <%= command.id %> <name> --limit 100',
    ];
    static flags = {
        limit: Flags.integer({
            char: 'l',
            description: 'Total number of log entries to retrieve',
            required: false,
            default: 50,
        }),
        json: Flags.boolean({
            char: 'j',
            description: 'Return logs in JSON format',
            required: false,
        }),
    };
    async run() {
        const { args, flags } = await this.parse(Logs);
        const spinner = Spinner({ text: `Finding logs for function "${args.name}"` }).start();
        const { deployedStack } = await readBlueprintOnDisk({ getStack: true, token: config.token });
        if (!deployedStack)
            this.error('Stack not found'); // returns
        const { projectId } = deployedStack;
        const { externalId } = findFunctionByName(deployedStack, args.name);
        const { ok, error, logs, total } = await logsAction(externalId, { limit: flags.limit }, { token: config.token, projectId });
        if (!ok) {
            spinner.error(`${red('Failed')} to retrieve logs`);
            this.log(`Error: ${error || 'Unknown error'}`);
            return;
        }
        const filteredLogs = logs.filter((entry) => entry.level && entry.message);
        if (filteredLogs.length === 0) {
            spinner.info(`No logs found for function ${args.name}`);
            return;
        }
        spinner.success(`${formatTitle('Function', args.name)} Logs`);
        if (!flags.json) {
            this.log(`Found ${bold(total)} log entries for function ${yellow(args.name)}`);
            if (logs.length < total) {
                this.log(`Here are the last ${bold(filteredLogs.length.toString())} entries`);
            }
            this.log('\n');
            for (const log of filteredLogs) {
                const { time, level, message } = log;
                const date = new Date(time);
                this.log(`${bold(date.toLocaleDateString())} ${bold(blue(date.toLocaleTimeString()))} ${logLevel(level)} ${message}`);
            }
        }
        else {
            this.log(JSON.stringify(filteredLogs, null, 2));
        }
    }
}
